<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ckti.github.io</id>
    <title>张前的小屋 • Posts by &#34;-[课程项目]&#34; category</title>
    <link href="https://ckti.github.io" />
    <updated>2024-10-18T08:59:46.472Z</updated>
    <category term="未完成" />
    <entry>
        <id>https://ckti.github.io/2024/10/18/Lab5_log/</id>
        <title>xv6操作系统实验lab5</title>
        <link rel="alternate" href="https://ckti.github.io/2024/10/18/Lab5_log/"/>
        <content type="html">&lt;h1 id=&#34;项目链接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#项目链接&#34;&gt;#&lt;/a&gt; 项目链接&lt;/h1&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2NrdDFpL3h2Ni1wdWJsaWMvdHJlZS9sYWI1LWNrdGk=&#34;&gt;项目仓库&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&#34;配置环境&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#配置环境&#34;&gt;#&lt;/a&gt; 配置环境&lt;/h1&gt;
&lt;h2 id=&#34;实验环境&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#实验环境&#34;&gt;#&lt;/a&gt; 实验环境&lt;/h2&gt;
&lt;p&gt;虚拟虚拟化平台：Unraid 6.12.13 远程运行&lt;/p&gt;
&lt;p&gt;操作系统：Ubuntu 22.04.4 LTS (GNU/Linux 6.8.0-40-generic x86_64)&lt;/p&gt;
&lt;p&gt;小型操作系统内核:xv6&lt;/p&gt;
&lt;h2 id=&#34;gcc配置&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#gcc配置&#34;&gt;#&lt;/a&gt; gcc 配置&lt;/h2&gt;
&lt;p&gt;输入 &lt;code&gt;sudo apt update&lt;/code&gt;  更新软件包列表&lt;/p&gt;
&lt;p&gt;输入 &lt;code&gt;sudo apt-get install -y build-essential git gcc-multilib &lt;/code&gt; 配置 gcc&lt;/p&gt;
&lt;p&gt;输入 &lt;code&gt;objdump -i&lt;/code&gt;  检查是否支持 64 位:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;user@Lab:~$ objdump -i&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;BFD header file version (GNU Binutils for Ubuntu) 2.38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;elf64-x86-64&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输入 &lt;code&gt;gcc -m32 -print-libgcc-file-name &lt;/code&gt; 查看 32 位 gcc 库文件路径:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;user:~$ gcc -m32 -print-libgcc-file-name &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;/usr/lib/gcc/x86_64-linux-gnu/11/32/libgcc.a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;出现上述输出，gcc 环境已配置好&lt;/p&gt;
&lt;h2 id=&#34;安装qemu以及xv6&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#安装qemu以及xv6&#34;&gt;#&lt;/a&gt; 安装 qemu 以及 xv6&lt;/h2&gt;
&lt;p&gt;输入 &lt;code&gt;sudo apt-get install qemu-system&lt;/code&gt;  安装 qemu&lt;/p&gt;
&lt;p&gt;输入 &lt;code&gt;qemu-system-i386 --version&lt;/code&gt;  查看 qemu 版本:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;user@Lab:~$ qemu-system-i386 --version&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;QEMU emulator version 6.2.0 (Debian 1:6.2+dfsg-2ubuntu6.22)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Copyright (c) 2003-2021 Fabrice Bellard and the QEMU Project developers&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;出现上述输出，qemu 环境已配置好&lt;/p&gt;
&lt;p&gt;输入 &lt;code&gt;git clone https://github.com/mit-pdos/xv6-public.git&lt;/code&gt;  下载 xv6 系统&lt;/p&gt;
&lt;p&gt;文件最后出现输出，说明操作系统镜像文件已准备好:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;+0 records in&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;+0 records out&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;512 bytes (512 B) copied, 0.000543844 s, 938 kB/s&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;dd if=kernal of=xf6.img seek=1 conv=notrunc&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;393+1 records in&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;393+1 records out&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;启动qemu&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#启动qemu&#34;&gt;#&lt;/a&gt; 启动 qemu&lt;/h2&gt;
&lt;p&gt;输入 &lt;code&gt;~/xv6$ echo &amp;quot;add-auto-load-safe-path $HOME/xv6/.gdbinit&amp;quot; &amp;gt; ~/.gdbinit&lt;/code&gt;  配置 gdb&lt;/p&gt;
&lt;p&gt;输入 &lt;code&gt;make qemu&lt;/code&gt;  启动 qemu, 出现如下报错:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;qemu-system-i386 -serial mon:stdio -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp 2 -m 512&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;gtk initialization failed&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;make: *** [Makefile:225: qemu] Error 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;经查询，其原因通常与 QEMU 的 GTK 版本有关，这可能是由于缺少 GTK 库或没有正确配置显示环境引起的。在此处我们选择采用 VNC 后端启动 QEMU, 通过修改其中的 &lt;code&gt;QEMUOPTS&lt;/code&gt;  变量如下，修改启动方式:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 -nographic $(QEMUEXTRA)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;命令行中输入 &lt;code&gt;make qemu&lt;/code&gt;  启动 qemu, 进入 qemu 界面:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;SeaBIOS (version 1.15.0-1)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1FF8B4A0+1FECB4A0 CA00&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Booting from Hard Disk..xv6...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;cpu0: starting 0&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap sta8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;init: starting sh&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;$&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&#34;xv6功能分析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#xv6功能分析&#34;&gt;#&lt;/a&gt; xv6 功能分析&lt;/h1&gt;
&lt;h2 id=&#34;xv6的内存布局&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#xv6的内存布局&#34;&gt;#&lt;/a&gt; xv6 的内存布局&lt;/h2&gt;
&lt;p&gt;在 xv6 中，内存布局分为内核空间和用户空间，&lt;/p&gt;
&lt;p&gt;内核位于内存空间的高地址部分，从一个固定点 (KERNBASE, 通常是 0x80000000) 开始。包含内核代码和数据、I/O 内存映射、内核栈、物理内存映射&lt;/p&gt;
&lt;p&gt;用户空间位于地址空间的低地址部分 (低于 KERNBASE), 主要包括文本段、数据段、堆段和栈段。其中栈段由中间的某个地址开始向上增长，本次实验的目的就是讲栈的分配方式由从下往上修改为从上往下。具体的内存分布见下图:&lt;/p&gt;
&lt;h2 id=&#34;相关函数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#相关函数&#34;&gt;#&lt;/a&gt; 相关函数&lt;/h2&gt;
&lt;p&gt;以下是与 xv6 内存布局和管理相关的文件及其简要功能描述:&lt;/p&gt;
&lt;h3 id=&#34;1-vmc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-vmc&#34;&gt;#&lt;/a&gt; 1.  &lt;code&gt;vm.c&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;负责虚拟内存管理，包括设置内核页表、分配和释放用户内存、复制进程内存等。关键函数包括  &lt;code&gt;setupkvm()&lt;/code&gt; 、 &lt;code&gt;allocuvm()&lt;/code&gt; 、 &lt;code&gt;deallocuvm()&lt;/code&gt;  和  &lt;code&gt;copyuvm()&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;2-procc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-procc&#34;&gt;#&lt;/a&gt; 2.  &lt;code&gt;proc.c&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;管理进程状态，包括创建新进程、扩展内存 ( &lt;code&gt;growproc()&lt;/code&gt; )、执行新程序 ( &lt;code&gt;exec()&lt;/code&gt; ) 等，使用  &lt;code&gt;copyuvm()&lt;/code&gt;  复制父进程的内存布局。&lt;/p&gt;
&lt;h3 id=&#34;3-trapc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3-trapc&#34;&gt;#&lt;/a&gt; 3.  &lt;code&gt;trap.c&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;处理异常和中断，包括页面错误 (Page Fault)。在  &lt;code&gt;trap()&lt;/code&gt;  函数中处理用户栈不足时的错误，调用  &lt;code&gt;allocuvm()&lt;/code&gt;  分配新页面。&lt;/p&gt;
&lt;h3 id=&#34;4-execc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#4-execc&#34;&gt;#&lt;/a&gt; 4.  &lt;code&gt;exec.c&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;加载可执行文件和初始化进程的内存布局，使用  &lt;code&gt;exec()&lt;/code&gt;  加载 ELF 文件，分配代码段、数据段和用户栈。&lt;/p&gt;
&lt;h3 id=&#34;5-syscallc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#5-syscallc&#34;&gt;#&lt;/a&gt; 5.  &lt;code&gt;syscall.c&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;处理系统调用，调用相应的内存管理功能，如  &lt;code&gt;fork&lt;/code&gt; 、 &lt;code&gt;exec&lt;/code&gt; 、 &lt;code&gt;wait&lt;/code&gt;  等，负责在用户空间和内核空间之间切换。&lt;/p&gt;
&lt;h3 id=&#34;6-memlayouth&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#6-memlayouth&#34;&gt;#&lt;/a&gt; 6.  &lt;code&gt;memlayout.h&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;定义内存布局的常量，包括内核空间和用户空间的起始和结束地址，如  &lt;code&gt;KERNBASE&lt;/code&gt; 、 &lt;code&gt;PHYSTOP&lt;/code&gt;  和  &lt;code&gt;USERTOP&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;7-mmuh&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#7-mmuh&#34;&gt;#&lt;/a&gt; 7.  &lt;code&gt;mmu.h&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;定义分页机制的宏和结构，描述页表项格式、页大小等，如  &lt;code&gt;PGSIZE&lt;/code&gt;  和各种页表项标志 (PTE)。&lt;/p&gt;
&lt;h3 id=&#34;8-kallocc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#8-kallocc&#34;&gt;#&lt;/a&gt; 8.  &lt;code&gt;kalloc.c&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;实现物理内存分配，提供  &lt;code&gt;kalloc()&lt;/code&gt;  和  &lt;code&gt;kfree()&lt;/code&gt;  函数，负责从物理内存中分配和释放页面。&lt;/p&gt;
&lt;h3 id=&#34;9-trapasms&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#9-trapasms&#34;&gt;#&lt;/a&gt; 9.  &lt;code&gt;trapasm.S&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;汇编代码，处理从用户态进入内核态时的上下文切换，设置陷阱帧并跳转到  &lt;code&gt;trap()&lt;/code&gt;  函数。&lt;/p&gt;
&lt;h3 id=&#34;10-kernelld&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#10-kernelld&#34;&gt;#&lt;/a&gt; 10.  &lt;code&gt;kernel.ld&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;链接脚本，定义内核的加载地址及各部分的内存布局，确保内核和用户进程的内存正确映射。&lt;/p&gt;
&lt;p&gt;这些文件和函数共同实现了 xv6 的内存管理和布局，确保系统在运行时能够有效地分配和使用内存。&lt;/p&gt;
&lt;h1 id=&#34;代码修改&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码修改&#34;&gt;#&lt;/a&gt; 代码修改&lt;/h1&gt;
&lt;h2 id=&#34;具体步骤&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#具体步骤&#34;&gt;#&lt;/a&gt; 具体步骤:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;重新定义用户地址空间布局。&lt;/li&gt;
&lt;li&gt;修改  &lt;code&gt;exec.c&lt;/code&gt;  以在高地址处分配栈。&lt;/li&gt;
&lt;li&gt;调整  &lt;code&gt;proc&lt;/code&gt;  结构，以正确跟踪用户栈和堆的边界。&lt;/li&gt;
&lt;li&gt;修改与内存管理相关的函数，确保它们能正确处理栈和堆的分配及地址验证。&lt;/li&gt;
&lt;li&gt;实现栈增长的处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;调整用户地址空间布局&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#调整用户地址空间布局&#34;&gt;#&lt;/a&gt; 调整用户地址空间布局&lt;/h2&gt;
&lt;p&gt;核心文件是  &lt;code&gt;memlayout.h&lt;/code&gt; , 它定义了内核和用户内存空间的布局。在  &lt;code&gt;memlayout.h&lt;/code&gt;  中， &lt;code&gt;KERNBASE&lt;/code&gt;  定义了用户地址空间的上限:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;// Key addresses for address space layout (see kmap in vm.c for layout)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#define KERNBASE 0x80000000         // First kernel virtual address&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个空间内修改栈的位置。&lt;/p&gt;
&lt;h2 id=&#34;修改execc中的栈分配逻辑&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#修改execc中的栈分配逻辑&#34;&gt;#&lt;/a&gt; 修改 &lt;code&gt;exec.c&lt;/code&gt;  中的栈分配逻辑&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;exec.c&lt;/code&gt;  负责加载用户程序并初始化用户地址空间。它使用  &lt;code&gt;allocuvm()&lt;/code&gt;  为程序分配内存，加载代码段和数据段，并为栈分配一页内存。以下是栈分配的步骤&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;exec.c&lt;/code&gt;  中，找到分配用户栈的代码，将栈分配到代码和堆的末尾，并分配两页 ( &lt;code&gt;2*PGSIZE&lt;/code&gt; ) 大小的栈空间；&lt;br&gt;
 修改栈的位置到  &lt;code&gt;KERNBASE - *PGSIZE&lt;/code&gt;  开始&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;// Allocate user stack at the top of the address space.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  uint stackbase = USERTOP - *PGSIZE;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  if((allocuvm(pgdir, stackbase, USERTOP)) == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    goto bad;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  clearpteu(pgdir, (char*)(stackbase));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  sp = USERTOP;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;调整proc结构修改-proc-sz的管理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#调整proc结构修改-proc-sz的管理&#34;&gt;#&lt;/a&gt; 调整 &lt;code&gt;proc&lt;/code&gt;  结构修改  &lt;code&gt;proc-&amp;gt;sz&lt;/code&gt;  的管理&lt;/h2&gt;
&lt;p&gt;当前  &lt;code&gt;proc-&amp;gt;sz&lt;/code&gt;  跟踪整个用户地址空间的大小，包括代码段、堆和栈。在修改后， &lt;code&gt;proc-&amp;gt;sz&lt;/code&gt;  只用于跟踪代码段和堆的大小，需要额外的字段来跟踪栈的起始位置。&lt;br&gt;
故在 &lt;code&gt;proc.h&lt;/code&gt;  中对 proc 结构设置新的结构项:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;// Per-process state&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;struct proc &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  uint sz;                     // Size of process memory (bytes)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  pde_t* pgdir;                // Page table&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  char *kstack;                // Bottom of kernel stack for this process&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  enum procstate state;        // Process state&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  int pid;                     // Process ID&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  struct proc *parent;         // Parent process&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  struct trapframe *tf;        // Trap frame for current syscall&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  struct context *context;     // swtch() here to run process&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  void *chan;                  // If non-zero, sleeping on chan&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  int killed;                  // If non-zero, have been killed&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  struct file *ofile[NOFILE];  // Open files&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  struct inode *cwd;           // Current directory&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  char name[16];               // Process name (debugging)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  uint stackbase;              // Base of the stack&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;修改内存管理的相关函数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#修改内存管理的相关函数&#34;&gt;#&lt;/a&gt; 修改内存管理的相关函数&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;proc.c&lt;/code&gt;  中，修改 &lt;code&gt;fork&lt;/code&gt;  函数以传递  &lt;code&gt;stackbase&lt;/code&gt;  参数给  &lt;code&gt;copyuvm&lt;/code&gt;  函数。&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;if((np-&amp;gt;pgdir = copyuvm(curproc-&amp;gt;pgdir, curproc-&amp;gt;sz, curproc-&amp;gt;stackbase)) == 0)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;vm.c&lt;/code&gt;  中修改  &lt;code&gt;copyuvm&lt;/code&gt;  函数，以确保在 fork 时正确地拷贝栈。:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;copyuvm(pde_t *pgdir, uint sz, uint stackbase)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   // Copy the stack&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  for(i = USERTOP - PGSIZE; i &amp;gt; stackbase  i -= PGSIZE)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      panic(&amp;quot;copyuvm: pte should exist&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if(!(*pte &amp;amp; PTE_P))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      panic(&amp;quot;copyuvm: page not present&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    pa = PTE_ADDR(*pte);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    flags = PTE_FLAGS(*pte);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if((mem = kalloc()) == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      goto bad;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    memmove(mem, (char*)P2V(pa), PGSIZE);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) &amp;lt; 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      kfree(mem);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      goto bad;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  return d;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;实现栈增长后的处理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#实现栈增长后的处理&#34;&gt;#&lt;/a&gt; 实现栈增长后的处理&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;trap.c&lt;/code&gt;  中，中处理页面错误，检测是否是栈溢出，并分配新的栈页:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;// 新增触发页错误(Page Fault)的情况&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;case T_PGFLT:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  if (rcr2() &amp;lt; USERTOP)// 条件检查:确保页面错误地址在用户栈范围内。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    cprintf(&amp;quot;page error %x &amp;quot;,rcr2());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    cprintf(&amp;quot;stack pos : %x\n&amp;quot;, myproc()-&amp;gt;stackbase);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // 为用户栈分配新的页面&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if ((myproc()-&amp;gt;stackbase = allocuvm(myproc()-&amp;gt;pgdir, myproc()-&amp;gt;stackbase - 1 * PGSIZE,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    myproc()-&amp;gt;stackbase)) == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      myproc()-&amp;gt;killed = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    myproc()-&amp;gt;stackbase-=PGSIZE; // 更新用户栈的栈顶位置&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    cprintf(&amp;quot;create a new page %x\n&amp;quot;, myproc()-&amp;gt;stackbase);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      //clearpteu(myproc()-&amp;gt;pgdir, (char *) (myproc()-&amp;gt;stackbase - PGSIZE));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    return;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  else&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     myproc()-&amp;gt;killed = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    break;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;syscall.c&lt;/code&gt;  中修改所有引用 sz 的地方，以反映新的栈位置。&lt;/p&gt;
&lt;h1 id=&#34;进行实验&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#进行实验&#34;&gt;#&lt;/a&gt; 进行实验&lt;/h1&gt;
&lt;h2 id=&#34;编写测试程序testcasec&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#编写测试程序testcasec&#34;&gt;#&lt;/a&gt; 编写测试程序 &lt;code&gt;testcase.c&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;主要结构&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#主要结构&#34;&gt;#&lt;/a&gt; 主要结构&lt;/h3&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;#include &amp;quot;types.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#include &amp;quot;stat.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#include &amp;quot;user.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 获取当前栈指针&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;uint get_stack_pointer() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 深度递归调用以测试更大规模的栈增长&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;void recursion(int depth) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 测试深度递归引发栈增长&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;void test_stack_growth() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 测试堆与栈的冲突&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;void test_stack_heap_collision() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;int main(int argc, char *argv[]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    test_stack_growth();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    test_stack_heap_collision();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    exit();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;测试栈的增长以及缺页分配&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#测试栈的增长以及缺页分配&#34;&gt;#&lt;/a&gt; 测试栈的增长以及缺页分配&lt;/h3&gt;
&lt;p&gt;编写如下程序:&lt;br&gt;
 其中， &lt;code&gt;get_stack_pointer&lt;/code&gt;  用于获取栈指针， &lt;code&gt;recursion&lt;/code&gt;  函数用于递归调用， &lt;code&gt;test_stack_growth&lt;/code&gt;  函数用于测试栈的增长。对于每次递归调用，输出当前栈指针。&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;// 获取当前栈指针&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;uint get_stack_pointer() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    uint sp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    asm volatile(&amp;quot;movl %%esp, %0&amp;quot; : &amp;quot;=r&amp;quot; (sp));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    return sp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 深度递归调用以测试更大规模的栈增长&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;void recursion(int depth) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    char buffer[4096];  // 分配4KB的空间,确保每次递归占用整页&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    memset(buffer, 1 , 4096); // 进行操作避免被优化掉&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    uint sp = get_stack_pointer();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    printf(1, &amp;quot;Recursion depth: %d, stack address: 0x%x\n&amp;quot;, depth , sp );&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // 在深度达到一定值之前递归&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if (depth &amp;lt; 100) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        recursion(depth + 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 测试深度递归引发栈增长&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;void test_stack_growth() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    printf(1, &amp;quot;\n=== Test: Stack Growth ===\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    printf(1, &amp;quot;Starting recursion test...\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    recursion(1);  // 初始递归调用,测试栈增长&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    printf(1, &amp;quot;Stack recursion test completed.\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;测试堆与栈的冲突&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#测试堆与栈的冲突&#34;&gt;#&lt;/a&gt; 测试堆与栈的冲突&lt;/h2&gt;
&lt;p&gt;在测试栈增长的基础上，添加 test_stack_heap_collision 函数，通过分配大量堆内存，测试堆与栈的冲突。&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;// 测试堆与栈的冲突&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;void test_stack_heap_collision() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    printf(1, &amp;quot;\n=== Test: Stack-Heap Collision ===\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    printf(1, &amp;quot;Starting stack-heap collision test...\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    printf(1, &amp;quot;Allocating 222MB of memory on the heap...\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    int * p = (int *)malloc(222*1024*1024 - 512*1024);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    *p = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    printf(1, &amp;quot;Making recursions .\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    recursion(1);  // 初始递归调用,测试栈增长&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    printf(1, &amp;quot;Stack recursion test completed.\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;运行测试程序&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#运行测试程序&#34;&gt;#&lt;/a&gt; 运行测试程序&lt;/h2&gt;
&lt;p&gt;编译并运行测试程序:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;$ make qemu-gdb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;Makefile&lt;/code&gt;  中添加编译 &lt;code&gt;testcase.c&lt;/code&gt;  的命令:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;UPROGS=\&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  _testcase\&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行 &lt;code&gt;make qemu&lt;/code&gt;  启动 QEMU, 并在 QEMU 中运行测试程序，观察输出，得出结论:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;$ testcase&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;实验结果&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#实验结果&#34;&gt;#&lt;/a&gt; 实验结果&lt;/h2&gt;
&lt;h3 id=&#34;测试栈的增长&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#测试栈的增长&#34;&gt;#&lt;/a&gt; 测试栈的增长&lt;/h3&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;=== Test: Stack Growth ===&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Starting recursion test...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7fffdf90 stack pos : 7fffe000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7fffd000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7fffcf90 stack pos : 7fffd000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7fffc000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7fffbf90 stack pos : 7fffc000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7fffb000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Recursion depth: 1, stack address: 0x7FFFBF90,buffer address: 0x7FFFBF90&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Recursion depth: 2, stack address: 0x7FFFBF90,buffer address: 0x7FFFCF90&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Recursion depth: 3, stack address: 0x7FFFBF90,buffer address: 0x7FFFDF90&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7fffaf70 stack pos : 7fffb000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7ff9ab70 stack pos : 7ff9b000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7ff9a000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7ff99b70 stack pos : 7ff9a000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7ff99000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7ff98b70 stack pos : 7ff99000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7ff98000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Recursion depth: 100, stack address: 0x7FF98B70,buffer address: 0x7FF98B70&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Stack recursion test completed&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从输出中可以看出，随着递归深度的增加，由于栈空间不足，系统会不断分配新的页，并且对于每次递归，系统都会输出栈帧地址和站上的数据，我们可以看到栈地址逐渐从高地址向低地址移动，说明我们的栈是向下增长的。&lt;/p&gt;
&lt;h3 id=&#34;测试堆与栈的冲突-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#测试堆与栈的冲突-2&#34;&gt;#&lt;/a&gt; 测试堆与栈的冲突&lt;/h3&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;=== Test: Stack-Heap Collision ===&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Starting stack-heap collision test...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Allocating 222MB of memory on the heap...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Making recursions .&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7fffdf90 stack pos : 7fffe000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7fffd000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7fffcf90 stack pos : 7fffd000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7fffc000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7fffbf90 stack pos : 7fffc000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7fffb000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Recursion depth: 1, stack address: 0x7FFFBF80&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Recursion depth: 2, stack address: 0x7FFFBF80&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Recursion depth: 3, stack address: 0x7FFFBF80&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7fffaf70 stack pos : 7fffb000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7fffa000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7fff9f70 stack pos : 7fffa000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7fff9000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7ffe2e70 stack pos : 7ffe3000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7ffe2000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7ffe1e70 stack pos : 7ffe2000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7ffe1000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7ffe0e70 stack pos : 7ffe1000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page 7ffe0000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Recursion depth: 28, stack address: 0x7FFE0E60&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Recursion depth: 29, stack address: 0x7FFE0E60&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Recursion depth: 30, stack address: 0x7FFE0E60&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;page error 7ffdfe50 stack pos : 7ffe0000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;allocuvm out of memory&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;The stack has grown into the heap space.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;create a new page fffff000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;stack is allocated in wrong place, End the process!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从输出中可以看出，当递归深度达到 28 时，此时栈已经进入堆空间。由于我们的程序在出现这种情况时选择重新分配栈空间，而在此时，由于无空间可分，最终栈被分入错误的地址，导致程序崩溃。&lt;/p&gt;
</content>
        <updated>2024-10-18T08:59:46.472Z</updated>
    </entry>
</feed>
