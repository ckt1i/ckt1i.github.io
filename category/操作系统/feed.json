{
    "version": "https://jsonfeed.org/version/1",
    "title": "张前的小屋 • All posts by \"操作系统\" category",
    "description": "",
    "home_page_url": "https://ckti.github.io",
    "items": [
        {
            "id": "https://ckti.github.io/2024/10/31/Lab5_log/",
            "url": "https://ckti.github.io/2024/10/31/Lab5_log/",
            "title": "xv6操作系统实验lab5",
            "date_published": "2024-10-31T05:54:21.000Z",
            "content_html": "<h1 id=\"项目链接\"><a class=\"markdownIt-Anchor\" href=\"#项目链接\">#</a> 项目链接</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NrdDFpL3h2Ni1wdWJsaWMvdHJlZS9sYWI1LWNrdGk=\">项目仓库</span></p>\n<h1 id=\"配置环境\"><a class=\"markdownIt-Anchor\" href=\"#配置环境\">#</a> 配置环境</h1>\n<h2 id=\"实验环境\"><a class=\"markdownIt-Anchor\" href=\"#实验环境\">#</a> 实验环境</h2>\n<p>虚拟虚拟化平台：Unraid 6.12.13 远程运行</p>\n<p>操作系统：Ubuntu 22.04.4 LTS (GNU/Linux 6.8.0-40-generic x86_64)</p>\n<p>小型操作系统内核:xv6</p>\n<h2 id=\"gcc配置\"><a class=\"markdownIt-Anchor\" href=\"#gcc配置\">#</a> gcc 配置</h2>\n<p>输入 <code>sudo apt update</code>  更新软件包列表</p>\n<p>输入 <code>sudo apt-get install -y build-essential git gcc-multilib </code> 配置 gcc</p>\n<p>输入 <code>objdump -i</code>  检查是否支持 64 位:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user@Lab:~$ objdump -i</span><br><span class=\"line\">BFD header file version (GNU Binutils for Ubuntu) 2.38</span><br><span class=\"line\">elf64-x86-64</span><br></pre></td></tr></table></figure>\n<p>输入 <code>gcc -m32 -print-libgcc-file-name </code> 查看 32 位 gcc 库文件路径:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user:~$ gcc -m32 -print-libgcc-file-name </span><br><span class=\"line\">/usr/lib/gcc/x86_64-linux-gnu/11/32/libgcc.a</span><br></pre></td></tr></table></figure>\n<p>出现上述输出，gcc 环境已配置好</p>\n<h2 id=\"安装qemu以及xv6\"><a class=\"markdownIt-Anchor\" href=\"#安装qemu以及xv6\">#</a> 安装 qemu 以及 xv6</h2>\n<p>输入 <code>sudo apt-get install qemu-system</code>  安装 qemu</p>\n<p>输入 <code>qemu-system-i386 --version</code>  查看 qemu 版本:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user@Lab:~$ qemu-system-i386 --version</span><br><span class=\"line\">QEMU emulator version 6.2.0 (Debian 1:6.2+dfsg-2ubuntu6.22)</span><br><span class=\"line\">Copyright (c) 2003-2021 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure>\n<p>出现上述输出，qemu 环境已配置好</p>\n<p>输入 <code>git clone https://github.com/mit-pdos/xv6-public.git</code>  下载 xv6 系统</p>\n<p>文件最后出现输出，说明操作系统镜像文件已准备好:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+0 records in</span><br><span class=\"line\">+0 records out</span><br><span class=\"line\">512 bytes (512 B) copied, 0.000543844 s, 938 kB/s</span><br><span class=\"line\">dd if=kernal of=xf6.img seek=1 conv=notrunc</span><br><span class=\"line\">393+1 records in</span><br><span class=\"line\">393+1 records out</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动qemu\"><a class=\"markdownIt-Anchor\" href=\"#启动qemu\">#</a> 启动 qemu</h2>\n<p>输入 <code>~/xv6$ echo &quot;add-auto-load-safe-path $HOME/xv6/.gdbinit&quot; &gt; ~/.gdbinit</code>  配置 gdb</p>\n<p>输入 <code>make qemu</code>  启动 qemu, 出现如下报错:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qemu-system-i386 -serial mon:stdio -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp 2 -m 512</span><br><span class=\"line\">gtk initialization failed</span><br><span class=\"line\">make: *** [Makefile:225: qemu] Error 1</span><br></pre></td></tr></table></figure>\n<p>经查询，其原因通常与 QEMU 的 GTK 版本有关，这可能是由于缺少 GTK 库或没有正确配置显示环境引起的。在此处我们选择采用 VNC 后端启动 QEMU, 通过修改其中的 <code>QEMUOPTS</code>  变量如下，修改启动方式:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 -nographic $(QEMUEXTRA)</span><br></pre></td></tr></table></figure>\n<p>命令行中输入 <code>make qemu</code>  启动 qemu, 进入 qemu 界面:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SeaBIOS (version 1.15.0-1)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1FF8B4A0+1FECB4A0 CA00</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Booting from Hard Disk..xv6...</span><br><span class=\"line\">cpu0: starting 0</span><br><span class=\"line\">sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap sta8</span><br><span class=\"line\">init: starting sh</span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n<h1 id=\"xv6功能分析\"><a class=\"markdownIt-Anchor\" href=\"#xv6功能分析\">#</a> xv6 功能分析</h1>\n<h2 id=\"xv6的内存布局\"><a class=\"markdownIt-Anchor\" href=\"#xv6的内存布局\">#</a> xv6 的内存布局</h2>\n<p>在 xv6 中，内存布局分为内核空间和用户空间，</p>\n<p>内核位于内存空间的高地址部分，从一个固定点 (KERNBASE, 通常是 0x80000000) 开始。包含内核代码和数据、I/O 内存映射、内核栈、物理内存映射</p>\n<p>用户空间位于地址空间的低地址部分 (低于 KERNBASE), 主要包括文本段、数据段、堆段和栈段。其中栈段由中间的某个地址开始向上增长，本次实验的目的就是讲栈的分配方式由从下往上修改为从上往下。具体的内存分布见下图:</p>\n<h2 id=\"相关函数\"><a class=\"markdownIt-Anchor\" href=\"#相关函数\">#</a> 相关函数</h2>\n<p>以下是与 xv6 内存布局和管理相关的文件及其简要功能描述:</p>\n<h3 id=\"1-vmc\"><a class=\"markdownIt-Anchor\" href=\"#1-vmc\">#</a> 1.  <code>vm.c</code></h3>\n<p>负责虚拟内存管理，包括设置内核页表、分配和释放用户内存、复制进程内存等。关键函数包括  <code>setupkvm()</code> 、 <code>allocuvm()</code> 、 <code>deallocuvm()</code>  和  <code>copyuvm()</code> 。</p>\n<h3 id=\"2-procc\"><a class=\"markdownIt-Anchor\" href=\"#2-procc\">#</a> 2.  <code>proc.c</code></h3>\n<p>管理进程状态，包括创建新进程、扩展内存 ( <code>growproc()</code> )、执行新程序 ( <code>exec()</code> ) 等，使用  <code>copyuvm()</code>  复制父进程的内存布局。</p>\n<h3 id=\"3-trapc\"><a class=\"markdownIt-Anchor\" href=\"#3-trapc\">#</a> 3.  <code>trap.c</code></h3>\n<p>处理异常和中断，包括页面错误 (Page Fault)。在  <code>trap()</code>  函数中处理用户栈不足时的错误，调用  <code>allocuvm()</code>  分配新页面。</p>\n<h3 id=\"4-execc\"><a class=\"markdownIt-Anchor\" href=\"#4-execc\">#</a> 4.  <code>exec.c</code></h3>\n<p>加载可执行文件和初始化进程的内存布局，使用  <code>exec()</code>  加载 ELF 文件，分配代码段、数据段和用户栈。</p>\n<h3 id=\"5-syscallc\"><a class=\"markdownIt-Anchor\" href=\"#5-syscallc\">#</a> 5.  <code>syscall.c</code></h3>\n<p>处理系统调用，调用相应的内存管理功能，如  <code>fork</code> 、 <code>exec</code> 、 <code>wait</code>  等，负责在用户空间和内核空间之间切换。</p>\n<h3 id=\"6-memlayouth\"><a class=\"markdownIt-Anchor\" href=\"#6-memlayouth\">#</a> 6.  <code>memlayout.h</code></h3>\n<p>定义内存布局的常量，包括内核空间和用户空间的起始和结束地址，如  <code>KERNBASE</code> 、 <code>PHYSTOP</code>  和  <code>USERTOP</code> 。</p>\n<h3 id=\"7-mmuh\"><a class=\"markdownIt-Anchor\" href=\"#7-mmuh\">#</a> 7.  <code>mmu.h</code></h3>\n<p>定义分页机制的宏和结构，描述页表项格式、页大小等，如  <code>PGSIZE</code>  和各种页表项标志 (PTE)。</p>\n<h3 id=\"8-kallocc\"><a class=\"markdownIt-Anchor\" href=\"#8-kallocc\">#</a> 8.  <code>kalloc.c</code></h3>\n<p>实现物理内存分配，提供  <code>kalloc()</code>  和  <code>kfree()</code>  函数，负责从物理内存中分配和释放页面。</p>\n<h3 id=\"9-trapasms\"><a class=\"markdownIt-Anchor\" href=\"#9-trapasms\">#</a> 9.  <code>trapasm.S</code></h3>\n<p>汇编代码，处理从用户态进入内核态时的上下文切换，设置陷阱帧并跳转到  <code>trap()</code>  函数。</p>\n<h3 id=\"10-kernelld\"><a class=\"markdownIt-Anchor\" href=\"#10-kernelld\">#</a> 10.  <code>kernel.ld</code></h3>\n<p>链接脚本，定义内核的加载地址及各部分的内存布局，确保内核和用户进程的内存正确映射。</p>\n<p>这些文件和函数共同实现了 xv6 的内存管理和布局，确保系统在运行时能够有效地分配和使用内存。</p>\n<h1 id=\"代码修改\"><a class=\"markdownIt-Anchor\" href=\"#代码修改\">#</a> 代码修改</h1>\n<h2 id=\"具体步骤\"><a class=\"markdownIt-Anchor\" href=\"#具体步骤\">#</a> 具体步骤:</h2>\n<ol>\n<li>重新定义用户地址空间布局。</li>\n<li>修改  <code>exec.c</code>  以在高地址处分配栈。</li>\n<li>调整  <code>proc</code>  结构，以正确跟踪用户栈和堆的边界。</li>\n<li>修改与内存管理相关的函数，确保它们能正确处理栈和堆的分配及地址验证。</li>\n<li>实现栈增长的处理</li>\n</ol>\n<h2 id=\"调整用户地址空间布局\"><a class=\"markdownIt-Anchor\" href=\"#调整用户地址空间布局\">#</a> 调整用户地址空间布局</h2>\n<p>核心文件是  <code>memlayout.h</code> , 它定义了内核和用户内存空间的布局。在  <code>memlayout.h</code>  中， <code>KERNBASE</code>  定义了用户地址空间的上限:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Key addresses for address space layout (see kmap in vm.c for layout)</span><br><span class=\"line\">#define KERNBASE 0x80000000         // First kernel virtual address</span><br></pre></td></tr></table></figure>\n<p>在这个空间内修改栈的位置。</p>\n<h2 id=\"修改execc中的栈分配逻辑\"><a class=\"markdownIt-Anchor\" href=\"#修改execc中的栈分配逻辑\">#</a> 修改 <code>exec.c</code>  中的栈分配逻辑</h2>\n<p><code>exec.c</code>  负责加载用户程序并初始化用户地址空间。它使用  <code>allocuvm()</code>  为程序分配内存，加载代码段和数据段，并为栈分配一页内存。以下是栈分配的步骤</p>\n<p>在 <code>exec.c</code>  中，找到分配用户栈的代码，将栈分配到代码和堆的末尾，并分配两页 ( <code>2*PGSIZE</code> ) 大小的栈空间；<br>\n 修改栈的位置到  <code>KERNBASE - *PGSIZE</code>  开始</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Allocate user stack at the top of the address space.</span><br><span class=\"line\">  uint stackbase = USERTOP - *PGSIZE;</span><br><span class=\"line\">  if((allocuvm(pgdir, stackbase, USERTOP)) == 0)</span><br><span class=\"line\">    goto bad;</span><br><span class=\"line\">  clearpteu(pgdir, (char*)(stackbase));</span><br><span class=\"line\">  sp = USERTOP;</span><br></pre></td></tr></table></figure>\n<h2 id=\"调整proc结构修改-proc-sz的管理\"><a class=\"markdownIt-Anchor\" href=\"#调整proc结构修改-proc-sz的管理\">#</a> 调整 <code>proc</code>  结构修改  <code>proc-&gt;sz</code>  的管理</h2>\n<p>当前  <code>proc-&gt;sz</code>  跟踪整个用户地址空间的大小，包括代码段、堆和栈。在修改后， <code>proc-&gt;sz</code>  只用于跟踪代码段和堆的大小，需要额外的字段来跟踪栈的起始位置。<br>\n故在 <code>proc.h</code>  中对 proc 结构设置新的结构项:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Per-process state</span><br><span class=\"line\">struct proc &#123;</span><br><span class=\"line\">  uint sz;                     // Size of process memory (bytes)</span><br><span class=\"line\">  pde_t* pgdir;                // Page table</span><br><span class=\"line\">  char *kstack;                // Bottom of kernel stack for this process</span><br><span class=\"line\">  enum procstate state;        // Process state</span><br><span class=\"line\">  int pid;                     // Process ID</span><br><span class=\"line\">  struct proc *parent;         // Parent process</span><br><span class=\"line\">  struct trapframe *tf;        // Trap frame for current syscall</span><br><span class=\"line\">  struct context *context;     // swtch() here to run process</span><br><span class=\"line\">  void *chan;                  // If non-zero, sleeping on chan</span><br><span class=\"line\">  int killed;                  // If non-zero, have been killed</span><br><span class=\"line\">  struct file *ofile[NOFILE];  // Open files</span><br><span class=\"line\">  struct inode *cwd;           // Current directory</span><br><span class=\"line\">  char name[16];               // Process name (debugging)</span><br><span class=\"line\">  uint stackbase;              // Base of the stack</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"修改内存管理的相关函数\"><a class=\"markdownIt-Anchor\" href=\"#修改内存管理的相关函数\">#</a> 修改内存管理的相关函数</h2>\n<p>在 <code>proc.c</code>  中，修改 <code>fork</code>  函数以传递  <code>stackbase</code>  参数给  <code>copyuvm</code>  函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if((np-&gt;pgdir = copyuvm(curproc-&gt;pgdir, curproc-&gt;sz, curproc-&gt;stackbase)) == 0)</span><br></pre></td></tr></table></figure>\n<p>在 <code>vm.c</code>  中修改  <code>copyuvm</code>  函数，以确保在 fork 时正确地拷贝栈。:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copyuvm(pde_t *pgdir, uint sz, uint stackbase)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   // Copy the stack</span><br><span class=\"line\">  for(i = USERTOP - PGSIZE; i &gt; stackbase  i -= PGSIZE)&#123;</span><br><span class=\"line\">    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)</span><br><span class=\"line\">      panic(&quot;copyuvm: pte should exist&quot;);</span><br><span class=\"line\">    if(!(*pte &amp; PTE_P))</span><br><span class=\"line\">      panic(&quot;copyuvm: page not present&quot;);</span><br><span class=\"line\">    pa = PTE_ADDR(*pte);</span><br><span class=\"line\">    flags = PTE_FLAGS(*pte);</span><br><span class=\"line\">    if((mem = kalloc()) == 0)</span><br><span class=\"line\">      goto bad;</span><br><span class=\"line\">    memmove(mem, (char*)P2V(pa), PGSIZE);</span><br><span class=\"line\">    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) &lt; 0) &#123;</span><br><span class=\"line\">      kfree(mem);</span><br><span class=\"line\">      goto bad;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return d;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现栈增长后的处理\"><a class=\"markdownIt-Anchor\" href=\"#实现栈增长后的处理\">#</a> 实现栈增长后的处理</h2>\n<p>在 <code>trap.c</code>  中，中处理页面错误，检测是否是栈溢出，并分配新的栈页:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 新增触发页错误(Page Fault)的情况</span><br><span class=\"line\">case T_PGFLT:</span><br><span class=\"line\">  </span><br><span class=\"line\">  if (rcr2() &lt; USERTOP)// 条件检查:确保页面错误地址在用户栈范围内。</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    cprintf(&quot;page error %x &quot;,rcr2());</span><br><span class=\"line\">    cprintf(&quot;stack pos : %x\\n&quot;, myproc()-&gt;stackbase);</span><br><span class=\"line\">    // 为用户栈分配新的页面</span><br><span class=\"line\">    if ((myproc()-&gt;stackbase = allocuvm(myproc()-&gt;pgdir, myproc()-&gt;stackbase - 1 * PGSIZE,</span><br><span class=\"line\">    myproc()-&gt;stackbase)) == 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      myproc()-&gt;killed = 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    myproc()-&gt;stackbase-=PGSIZE; // 更新用户栈的栈顶位置</span><br><span class=\"line\">    cprintf(&quot;create a new page %x\\n&quot;, myproc()-&gt;stackbase);</span><br><span class=\"line\">      //clearpteu(myproc()-&gt;pgdir, (char *) (myproc()-&gt;stackbase - PGSIZE));</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">     myproc()-&gt;killed = 1;</span><br><span class=\"line\">    break;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>syscall.c</code>  中修改所有引用 sz 的地方，以反映新的栈位置。</p>\n<h1 id=\"进行实验\"><a class=\"markdownIt-Anchor\" href=\"#进行实验\">#</a> 进行实验</h1>\n<h2 id=\"编写测试程序testcasec\"><a class=\"markdownIt-Anchor\" href=\"#编写测试程序testcasec\">#</a> 编写测试程序 <code>testcase.c</code></h2>\n<h3 id=\"主要结构\"><a class=\"markdownIt-Anchor\" href=\"#主要结构\">#</a> 主要结构</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;types.h&quot;</span><br><span class=\"line\">#include &quot;stat.h&quot;</span><br><span class=\"line\">#include &quot;user.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取当前栈指针</span><br><span class=\"line\">uint get_stack_pointer() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 深度递归调用以测试更大规模的栈增长</span><br><span class=\"line\">void recursion(int depth) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 测试深度递归引发栈增长</span><br><span class=\"line\">void test_stack_growth() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 测试堆与栈的冲突</span><br><span class=\"line\">void test_stack_heap_collision() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char *argv[]) &#123;</span><br><span class=\"line\">    test_stack_growth();</span><br><span class=\"line\">    test_stack_heap_collision();</span><br><span class=\"line\">    exit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试栈的增长以及缺页分配\"><a class=\"markdownIt-Anchor\" href=\"#测试栈的增长以及缺页分配\">#</a> 测试栈的增长以及缺页分配</h3>\n<p>编写如下程序:<br>\n 其中， <code>get_stack_pointer</code>  用于获取栈指针， <code>recursion</code>  函数用于递归调用， <code>test_stack_growth</code>  函数用于测试栈的增长。对于每次递归调用，输出当前栈指针。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取当前栈指针</span><br><span class=\"line\">uint get_stack_pointer() &#123;</span><br><span class=\"line\">    uint sp;</span><br><span class=\"line\">    asm volatile(&quot;movl %%esp, %0&quot; : &quot;=r&quot; (sp));</span><br><span class=\"line\">    return sp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 深度递归调用以测试更大规模的栈增长</span><br><span class=\"line\">void recursion(int depth) &#123;</span><br><span class=\"line\">    char buffer[4096];  // 分配4KB的空间,确保每次递归占用整页</span><br><span class=\"line\">    memset(buffer, 1 , 4096); // 进行操作避免被优化掉</span><br><span class=\"line\">    uint sp = get_stack_pointer();</span><br><span class=\"line\">    printf(1, &quot;Recursion depth: %d, stack address: 0x%x\\n&quot;, depth , sp );</span><br><span class=\"line\"></span><br><span class=\"line\">    // 在深度达到一定值之前递归</span><br><span class=\"line\">    if (depth &lt; 100) &#123;</span><br><span class=\"line\">        recursion(depth + 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 测试深度递归引发栈增长</span><br><span class=\"line\">void test_stack_growth() &#123;</span><br><span class=\"line\">    printf(1, &quot;\\n=== Test: Stack Growth ===\\n&quot;);</span><br><span class=\"line\">    printf(1, &quot;Starting recursion test...\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    recursion(1);  // 初始递归调用,测试栈增长</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(1, &quot;Stack recursion test completed.\\n&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试堆与栈的冲突\"><a class=\"markdownIt-Anchor\" href=\"#测试堆与栈的冲突\">#</a> 测试堆与栈的冲突</h2>\n<p>在测试栈增长的基础上，添加 test_stack_heap_collision 函数，通过分配大量堆内存，测试堆与栈的冲突。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 测试堆与栈的冲突</span><br><span class=\"line\">void test_stack_heap_collision() &#123;</span><br><span class=\"line\">    printf(1, &quot;\\n=== Test: Stack-Heap Collision ===\\n&quot;);</span><br><span class=\"line\">    printf(1, &quot;Starting stack-heap collision test...\\n&quot;);</span><br><span class=\"line\">    printf(1, &quot;Allocating 222MB of memory on the heap...\\n&quot;);</span><br><span class=\"line\">    int * p = (int *)malloc(222*1024*1024 - 512*1024);</span><br><span class=\"line\">    *p = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(1, &quot;Making recursions .\\n&quot;);</span><br><span class=\"line\">    recursion(1);  // 初始递归调用,测试栈增长</span><br><span class=\"line\">    printf(1, &quot;Stack recursion test completed.\\n&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行测试程序\"><a class=\"markdownIt-Anchor\" href=\"#运行测试程序\">#</a> 运行测试程序</h2>\n<p>编译并运行测试程序:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make qemu-gdb</span><br></pre></td></tr></table></figure>\n<p>在 <code>Makefile</code>  中添加编译 <code>testcase.c</code>  的命令:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPROGS=\\</span><br><span class=\"line\">  _testcase\\</span><br></pre></td></tr></table></figure>\n<p>运行 <code>make qemu</code>  启动 QEMU, 并在 QEMU 中运行测试程序，观察输出，得出结论:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ testcase</span><br></pre></td></tr></table></figure>\n<h2 id=\"实验结果\"><a class=\"markdownIt-Anchor\" href=\"#实验结果\">#</a> 实验结果</h2>\n<h3 id=\"测试栈的增长\"><a class=\"markdownIt-Anchor\" href=\"#测试栈的增长\">#</a> 测试栈的增长</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=== Test: Stack Growth ===</span><br><span class=\"line\">Starting recursion test...</span><br><span class=\"line\">page error 7fffdf90 stack pos : 7fffe000</span><br><span class=\"line\">create a new page 7fffd000</span><br><span class=\"line\">page error 7fffcf90 stack pos : 7fffd000</span><br><span class=\"line\">create a new page 7fffc000</span><br><span class=\"line\">page error 7fffbf90 stack pos : 7fffc000</span><br><span class=\"line\">create a new page 7fffb000</span><br><span class=\"line\">Recursion depth: 1, stack address: 0x7FFFBF90,buffer address: 0x7FFFBF90</span><br><span class=\"line\">Recursion depth: 2, stack address: 0x7FFFBF90,buffer address: 0x7FFFCF90</span><br><span class=\"line\">Recursion depth: 3, stack address: 0x7FFFBF90,buffer address: 0x7FFFDF90</span><br><span class=\"line\">page error 7fffaf70 stack pos : 7fffb000</span><br><span class=\"line\">...</span><br><span class=\"line\">page error 7ff9ab70 stack pos : 7ff9b000</span><br><span class=\"line\">create a new page 7ff9a000</span><br><span class=\"line\">page error 7ff99b70 stack pos : 7ff9a000</span><br><span class=\"line\">create a new page 7ff99000</span><br><span class=\"line\">page error 7ff98b70 stack pos : 7ff99000</span><br><span class=\"line\">create a new page 7ff98000</span><br><span class=\"line\">Recursion depth: 100, stack address: 0x7FF98B70,buffer address: 0x7FF98B70</span><br><span class=\"line\">Stack recursion test completed</span><br></pre></td></tr></table></figure>\n<p>从输出中可以看出，随着递归深度的增加，由于栈空间不足，系统会不断分配新的页，并且对于每次递归，系统都会输出栈帧地址和站上的数据，我们可以看到栈地址逐渐从高地址向低地址移动，说明我们的栈是向下增长的。</p>\n<h3 id=\"测试堆与栈的冲突-2\"><a class=\"markdownIt-Anchor\" href=\"#测试堆与栈的冲突-2\">#</a> 测试堆与栈的冲突</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">=== Test: Stack-Heap Collision ===</span><br><span class=\"line\">Starting stack-heap collision test...</span><br><span class=\"line\">Allocating 222MB of memory on the heap...</span><br><span class=\"line\">Making recursions .</span><br><span class=\"line\">page error 7fffdf90 stack pos : 7fffe000</span><br><span class=\"line\">create a new page 7fffd000</span><br><span class=\"line\">page error 7fffcf90 stack pos : 7fffd000</span><br><span class=\"line\">create a new page 7fffc000</span><br><span class=\"line\">page error 7fffbf90 stack pos : 7fffc000</span><br><span class=\"line\">create a new page 7fffb000</span><br><span class=\"line\">Recursion depth: 1, stack address: 0x7FFFBF80</span><br><span class=\"line\">Recursion depth: 2, stack address: 0x7FFFBF80</span><br><span class=\"line\">Recursion depth: 3, stack address: 0x7FFFBF80</span><br><span class=\"line\">page error 7fffaf70 stack pos : 7fffb000</span><br><span class=\"line\">create a new page 7fffa000</span><br><span class=\"line\">page error 7fff9f70 stack pos : 7fffa000</span><br><span class=\"line\">create a new page 7fff9000</span><br><span class=\"line\">...</span><br><span class=\"line\">page error 7ffe2e70 stack pos : 7ffe3000</span><br><span class=\"line\">create a new page 7ffe2000</span><br><span class=\"line\">page error 7ffe1e70 stack pos : 7ffe2000</span><br><span class=\"line\">create a new page 7ffe1000</span><br><span class=\"line\">page error 7ffe0e70 stack pos : 7ffe1000</span><br><span class=\"line\">create a new page 7ffe0000</span><br><span class=\"line\">Recursion depth: 28, stack address: 0x7FFE0E60</span><br><span class=\"line\">Recursion depth: 29, stack address: 0x7FFE0E60</span><br><span class=\"line\">Recursion depth: 30, stack address: 0x7FFE0E60</span><br><span class=\"line\">page error 7ffdfe50 stack pos : 7ffe0000</span><br><span class=\"line\">allocuvm out of memory</span><br><span class=\"line\">The stack has grown into the heap space.</span><br><span class=\"line\">create a new page fffff000</span><br><span class=\"line\">stack is allocated in wrong place, End the process!</span><br></pre></td></tr></table></figure>\n<p>从输出中可以看出，当递归深度达到 28 时，此时栈已经进入堆空间。由于我们的程序在出现这种情况时选择重新分配栈空间，而在此时，由于无空间可分，最终栈被分入错误的地址，导致程序崩溃。</p>\n",
            "tags": []
        }
    ]
}